# NEXTIER DEAL ORIGINATION MACHINE
## Event-Driven Lead Management System with AI Agent Orchestration

**Version**: 3.0  
**Date**: 2025-12-21  
**Architecture**: Nextier-Centric Event-Driven Platform  
**Primary Deployment**: [East Coast Business Brokers](https://eastcoastbusinessbrokers.com/)  
**White-Label Platform**: [NextierGlobal.ai](https://www.nextierglobal.ai/)  

---

## ğŸ¯ PLATFORM POSITIONING

### The Deal Origination Machine

Nextier is the **central intelligence platform** powering deal origination for business brokers, real estate professionals, and M&A advisors. Built as a white-label SaaS solution, it combines:

- **AI-Powered Lead Generation** â†’ LUCI scans internal lists, scores leads, triggers campaigns
- **Multi-Agent Orchestration** â†’ GIANNA (outreach), CATHY (nurture), SABRINA (close)
- **Event-Driven Architecture** â†’ Every action creates traceable, auditable events
- **Persistent ID Tracking** â†’ LeadID, CampaignID, ThreadID across entire lifecycle

### ğŸŒŠ "BE LIKE WATER" - Adaptive Platform Philosophy

> *"Be water, my friend. Water can flow, or it can crash."* â€” Bruce Lee

Nextier is **formless infrastructure** that adapts to any deal-making context:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    NEXTIER: LIKE WATER - INFINITE FORM                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   SAME CORE ENGINE          â†’    DIFFERENT POSITIONING                      â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                       â”‚
â”‚                                                                              â”‚
â”‚   LUCI + GIANNA + SABRINA   â†’    Business Broker CRM                        â”‚
â”‚   LUCI + GIANNA + SABRINA   â†’    Real Estate Investor Platform              â”‚
â”‚   LUCI + GIANNA + SABRINA   â†’    M&A Deal Sourcing Tool                     â”‚
â”‚   LUCI + GIANNA + SABRINA   â†’    PE Proprietary Deal Flow                   â”‚
â”‚   LUCI + GIANNA + SABRINA   â†’    Roll-Up Acquisition Engine                 â”‚
â”‚   LUCI + GIANNA + SABRINA   â†’    Exit Prep Advisory Platform                â”‚
â”‚   LUCI + GIANNA + SABRINA   â†’    Consultant Lead Generation                 â”‚
â”‚                                                                              â”‚
â”‚   ONE PLATFORM. INFINITE APPLICATIONS. LIKE WATER.                          â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**The Water Principle:**
| Aspect | How Nextier Flows |
|--------|-------------------|
| **Brand** | White-label to any company name, logo, domain |
| **Persona** | Same AI agents, different voice/personality per client |
| **Data Source** | USBizData, Apollo, RealEstateAPI, client CSV - any source |
| **Channel** | SMS, Email, Voice, Direct Mail - same orchestration |
| **Vertical** | Business brokerage, real estate, consulting, PE - same engine |
| **Geography** | Local market, regional, national - same infrastructure |
| **Deal Size** | $500K exits to $50M acquisitions - same workflow |

**We take it where it needs to go.**

---

## ğŸ­ TARGET PERSONAS & USE CASES

### Primary Market: Business Brokerage & M&A

| Persona | Description | Key Needs |
|---------|-------------|-----------|
| **Business Brokers** | Help owners sell $1M-$10M businesses | Deal flow, exit-ready leads, valuation prep |
| **Real Estate Agents** | Commercial & investment property focus | Off-market deals, investor matching |
| **Real Estate Brokers** | Multi-agent firms with transaction volume | Lead distribution, pipeline visibility |
| **M&A Consultants** | Mid-market advisory ($5M-$50M deals) | Qualified sellers, due diligence support |
| **Private Equity Firms** | Platform acquisitions & add-ons | Deal sourcing, proprietary deal flow |
| **Roll-Up Operators** | Industry consolidation plays | Sector-specific targeting, owner outreach |

### Nextier Product Suite

| Division | Product | Description | Persona Fit |
|----------|---------|-------------|-------------|
| **Nextier Technologies** | AI Audit + Blueprint | AI readiness assessment with custom implementation roadmap | Consultants, PE firms, Roll-up operators |
| **Nextier Technologies** | Business Mindmaps | Visual AI architecture unique to each company's operations | All personas |
| **Nextier Technologies** | Technology Integration | Full AI/automation stack implementation & training | PE firms, Roll-up operators |
| **Nextier Exits** | Deal Origination Engine | Full LUCI â†’ GIANNA â†’ SABRINA AI agent pipeline | Business brokers, M&A advisors |
| **Nextier Exits** | Seller Matching | AI-powered buyer/seller matching with probability scoring | Business brokers, PE firms |
| **Nextier Exit Prep** | 12-Month Exit Program | Comprehensive exit preparation workflow & valuation optimization | Business owners, M&A advisors |
| **Nextier Exit Prep** | Valuation Enhancement | Pre-exit improvements to maximize sale price | Business brokers, Consultants |
| **Nextier Evaluations** | Business Spinoff Analysis | Evaluate business units for potential spinoff opportunities | PE firms, Consultants |
| **Nextier Evaluations** | Real Estate Spinoff Analysis | Separate RE holdings from operating business valuation | Real estate brokers, Business brokers |
| **Nextier Evaluations** | Combined Entity Valuation | Holistic business + real estate portfolio assessment | M&A advisors, PE firms |

### Nextier Brand Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         NEXTIER GLOBAL PLATFORM                              â”‚
â”‚                     https://www.nextierglobal.ai/                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚    NEXTIER      â”‚  â”‚    NEXTIER      â”‚  â”‚    NEXTIER      â”‚              â”‚
â”‚  â”‚  TECHNOLOGIES   â”‚  â”‚     EXITS       â”‚  â”‚   EXIT PREP     â”‚              â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”‚
â”‚  â”‚ â€¢ AI Audit      â”‚  â”‚ â€¢ Deal Engine   â”‚  â”‚ â€¢ 12-Month Prog â”‚              â”‚
â”‚  â”‚ â€¢ Blueprints    â”‚  â”‚ â€¢ Seller Match  â”‚  â”‚ â€¢ Valuation Opt â”‚              â”‚
â”‚  â”‚ â€¢ Mindmaps      â”‚  â”‚ â€¢ Lead Gen      â”‚  â”‚ â€¢ Exit Readinessâ”‚              â”‚
â”‚  â”‚ â€¢ Tech Stack    â”‚  â”‚ â€¢ Agent AI      â”‚  â”‚ â€¢ Owner Coachingâ”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚  â”‚         NEXTIER EVALUATIONS             â”‚                                â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                â”‚
â”‚  â”‚ â€¢ Business Spinoff Analysis             â”‚                                â”‚
â”‚  â”‚ â€¢ Real Estate Spinoff Analysis          â”‚                                â”‚
â”‚  â”‚ â€¢ Combined Entity Valuation             â”‚                                â”‚
â”‚  â”‚ â€¢ Debt/Equity Structure Optimization    â”‚                                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ—ï¸ SYSTEM ARCHITECTURE OVERVIEW

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     EVENT-DRIVEN LEAD MANAGEMENT                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ”„ EVENT TRIGGERS                                                 â”‚
â”‚ â”œâ”€ USBizData Import Event                                          â”‚
â”‚ â”œâ”€ LUCI Activation Event                                           â”‚
â”‚ â”œâ”€ Skip Trace Completion Event                                     â”‚
â”‚ â”œâ”€ Lead Queue Event                                                â”‚
â”‚ â”œâ”€ Lead Assignment Event                                           â”‚
â”‚ â””â”€ SMS Campaign Initiation Event                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ¤– LUCI AI AGENT LAYER                                            â”‚
â”‚ â”œâ”€ Data Processing & Analysis                                      â”‚
â”‚ â”œâ”€ Skip Trace Orchestration                                        â”‚
â”‚ â”œâ”€ Lead Quality Scoring                                            â”‚
â”‚ â”œâ”€ Queue Management                                                â”‚
â”‚ â””â”€ Campaign Recommendations                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ“Š PERSISTENT ID SYSTEM                                            â”‚
â”‚ â”œâ”€ LeadID (Immutable UUID)                                         â”‚
â”‚ â”œâ”€ RecordID (USBizData source)                                     â”‚
â”‚ â”œâ”€ CampaignID (SMS campaign batch)                                 â”‚
â”‚ â”œâ”€ ThreadID (Communication session)                                â”‚
â”‚ â”œâ”€ AssignmentID (Lead routing)                                     â”‚
â”‚ â””â”€ ExecutionID (Pipeline instance)                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ’¾ CENTRALIZED DATABASE                                            â”‚
â”‚ â”œâ”€ Lead Master Records                                             â”‚
â”‚ â”œâ”€ Communication Threads                                           â”‚
â”‚ â”œâ”€ Campaign Analytics                                              â”‚
â”‚ â”œâ”€ Status Lifecycle Tracking                                       â”‚
â”‚ â””â”€ Complete Audit Trail                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ—ï¸ COMPREHENSIVE DATABASE SCHEMA

### Core Lead Management Tables

```sql
-- Event Triggers
CREATE TABLE event_triggers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_type VARCHAR(100) NOT NULL, -- 'USBIZDATA_IMPORT', 'LUCI_ACTIVATED', etc.
    event_source VARCHAR(100) NOT NULL, -- 'usbizdata_api', 'luci_agent', 'manual'
    event_data JSONB NOT NULL,
    event_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed BOOLEAN DEFAULT FALSE,
    processing_started_at TIMESTAMP WITH TIME ZONE,
    processing_completed_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- LUCI AI Agent Sessions
CREATE TABLE luci_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_name VARCHAR(255),
    trigger_event_id UUID REFERENCES event_triggers(id),
    status VARCHAR(50) DEFAULT 'active', -- 'active', 'paused', 'completed', 'failed'
    -- Configuration
    max_records_to_process INTEGER DEFAULT 2000,
    skip_trace_enabled BOOLEAN DEFAULT TRUE,
    lead_scoring_enabled BOOLEAN DEFAULT TRUE,
    auto_queue_enabled BOOLEAN DEFAULT TRUE,
    -- Progress Tracking
    total_records INTEGER DEFAULT 0,
    processed_records INTEGER DEFAULT 0,
    skip_traced_records INTEGER DEFAULT 0,
    queued_leads INTEGER DEFAULT 0,
    -- AI Analysis
    processing_strategy JSONB,
    quality_thresholds JSONB,
    target_segments JSONB,
    started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    completed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Lead Master Records (Persistent ID System)
CREATE TABLE leads_master (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id VARCHAR(50) UNIQUE NOT NULL, -- Human-readable ID like "LEAD-2025-001234"
    record_id UUID REFERENCES usbizdata_records(id), -- Source USBizData record
    luci_session_id UUID REFERENCES luci_sessions(id),
    -- Lead Information
    business_name VARCHAR(500) NOT NULL,
    owner_name VARCHAR(200),
    owner_title VARCHAR(200),
    primary_phone VARCHAR(20),
    mobile_phone VARCHAR(20),
    business_email VARCHAR(255),
    website VARCHAR(500),
    industry VARCHAR(255),
    revenue_range VARCHAR(100),
    employee_count INTEGER,
    -- Location
    address TEXT,
    city VARCHAR(100),
    state VARCHAR(50),
    zip_code VARCHAR(20),
    -- LUCI Analysis
    quality_score DECIMAL(5,2), -- 0-100 scoring
    priority_level INTEGER DEFAULT 50, -- 1-100 priority
    lead_source VARCHAR(100) DEFAULT 'usbizdata',
    acquisition_channel VARCHAR(100),
    -- Status Lifecycle
    current_status VARCHAR(50) DEFAULT 'new', -- 'new', 'qualified', 'contacted', 'engaged', 'proposal', 'closed'
    status_updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    status_updated_by UUID,
    -- Assignment
    assigned_agent VARCHAR(50), -- 'luci', 'gianna', 'cathy', 'sabrina'
    assigned_at TIMESTAMP WITH TIME ZONE,
    assignment_reason TEXT,
    -- Timestamps
    first_contact_at TIMESTAMP WITH TIME ZONE,
    last_activity_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Lead Queue System
CREATE TABLE lead_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID REFERENCES leads_master(id) ON DELETE CASCADE,
    queue_name VARCHAR(100) NOT NULL, -- 'high_priority', 'standard', 'follow_up'
    priority_score INTEGER DEFAULT 50,
    queue_status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'processing', 'completed', 'failed'
    -- Queue Management
    enqueued_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processing_started_at TIMESTAMP WITH TIME ZONE,
    processing_completed_at TIMESTAMP WITH TIME ZONE,
    assigned_agent VARCHAR(50),
    -- LUCI Recommendations
    recommended_action VARCHAR(200),
    suggested_timing TIMESTAMP WITH TIME ZONE,
    quality_flags JSONB,
    -- Assignment Tracking
    assignment_id UUID, -- References lead_assignments
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Lead Assignments
CREATE TABLE lead_assignments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    assignment_id VARCHAR(50) UNIQUE NOT NULL, -- "ASSIGN-2025-001234"
    lead_id UUID REFERENCES leads_master(id) ON DELETE CASCADE,
    assigned_agent VARCHAR(50) NOT NULL, -- 'gianna', 'cathy', 'sabrina', 'neva'
    assignment_type VARCHAR(100) NOT NULL, -- 'outreach', 'follow_up', 'closing', 'research'
    -- Assignment Details
    assignment_reason TEXT,
    priority_level INTEGER DEFAULT 50,
    due_date TIMESTAMP WITH TIME ZONE,
    -- Status
    assignment_status VARCHAR(50) DEFAULT 'active', -- 'active', 'completed', 'cancelled', 'escalated'
    assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    completed_at TIMESTAMP WITH TIME ZONE,
    -- Performance Metrics
    response_time_minutes INTEGER,
    engagement_score DECIMAL(3,2),
    -- Notes and Context
    assignment_context JSONB,
    completion_notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Communication Threads
CREATE TABLE communication_threads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    thread_id VARCHAR(50) UNIQUE NOT NULL, -- "THREAD-2025-001234"
    lead_id UUID REFERENCES leads_master(id) ON DELETE CASCADE,
    campaign_id UUID REFERENCES sms_campaigns(id),
    assignment_id UUID REFERENCES lead_assignments(id),
    -- Thread Information
    thread_type VARCHAR(50) NOT NULL, -- 'sms', 'email', 'call', 'meeting'
    communication_channel VARCHAR(50) NOT NULL,
    thread_status VARCHAR(50) DEFAULT 'active', -- 'active', 'closed', 'archived'
    -- Participants
    primary_participant VARCHAR(100), -- Lead contact info
    assigned_agent VARCHAR(50),
    -- Thread Context
    thread_subject TEXT,
    initial_message TEXT,
    thread_context JSONB,
    -- Lifecycle
    started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    last_message_at TIMESTAMP WITH TIME ZONE,
    closed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Communication Events (Every Touchpoint)
CREATE TABLE communication_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id VARCHAR(50) UNIQUE NOT NULL, -- "EVENT-2025-001234"
    lead_id UUID REFERENCES leads_master(id) ON DELETE CASCADE,
    thread_id UUID REFERENCES communication_threads(id) ON DELETE CASCADE,
    campaign_id UUID REFERENCES sms_campaigns(id),
    assignment_id UUID REFERENCES lead_assignments(id),
    -- Event Details
    event_type VARCHAR(100) NOT NULL, -- 'sms_sent', 'sms_received', 'email_sent', 'call_made'
    event_subtype VARCHAR(100), -- 'initial_outreach', 'follow_up', 'response', 'opt_out'
    -- Content
    message_content TEXT,
    message_direction VARCHAR(20) NOT NULL, -- 'outbound', 'inbound'
    -- Metadata
    event_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    delivery_status VARCHAR(50), -- 'sent', 'delivered', 'failed', 'read'
    response_required BOOLEAN DEFAULT FALSE,
    -- Technical Details
    external_id VARCHAR(200), -- Twilio Message SID, Email ID, etc.
    technical_metadata JSONB,
    -- Analytics
    engagement_score DECIMAL(3,2),
    sentiment_score DECIMAL(3,2),
    -- Quality Assurance
    quality_flags JSONB,
    manual_review_required BOOLEAN DEFAULT FALSE,
    reviewed_by UUID,
    reviewed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Lead Status History (Complete Audit Trail)
CREATE TABLE lead_status_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID REFERENCES leads_master(id) ON DELETE CASCADE,
    from_status VARCHAR(50),
    to_status VARCHAR(50) NOT NULL,
    status_changed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    changed_by VARCHAR(100), -- Agent name or system
    change_reason TEXT,
    change_context JSONB,
    -- Impact Analysis
    conversion_probability DECIMAL(3,2),
    revenue_potential DECIMAL(15,2),
    priority_adjustment INTEGER,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Campaign Lead Mapping
CREATE TABLE campaign_lead_mapping (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_id UUID REFERENCES sms_campaigns(id) ON DELETE CASCADE,
    lead_id UUID REFERENCES leads_master(id) ON DELETE CASCADE,
    -- Mapping Details
    lead_position INTEGER, -- Position in campaign sequence
    targeting_criteria JSONB,
    personalization_data JSONB,
    -- Performance
    messages_sent INTEGER DEFAULT 0,
    responses_received INTEGER DEFAULT 0,
    engagement_score DECIMAL(3,2),
    conversion_status VARCHAR(50), -- 'not_converted', 'responded', 'qualified', 'converted'
    -- Timestamps
    added_to_campaign_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    first_message_at TIMESTAMP WITH TIME ZONE,
    last_interaction_at TIMESTAMP WITH TIME ZONE,
    converted_at TIMESTAMP WITH TIME ZONE
);

-- Indexes for Performance
CREATE INDEX idx_event_triggers_type ON event_triggers(event_type);
CREATE INDEX idx_event_triggers_processed ON event_triggers(processed);
CREATE INDEX idx_luci_sessions_status ON luci_sessions(status);
CREATE INDEX idx_leads_master_status ON leads_master(current_status);
CREATE INDEX idx_leads_master_priority ON leads_master(priority_level DESC);
CREATE INDEX idx_leads_master_assignment ON leads_master(assigned_agent);
CREATE INDEX idx_lead_queue_status ON lead_queue(queue_status);
CREATE INDEX idx_lead_queue_priority ON lead_queue(priority_score DESC);
CREATE INDEX idx_lead_assignments_status ON lead_assignments(assignment_status);
CREATE INDEX idx_communication_threads_lead ON communication_threads(lead_id);
CREATE INDEX idx_communication_events_lead ON communication_events(lead_id);
CREATE INDEX idx_communication_events_timestamp ON communication_events(event_timestamp);
CREATE INDEX idx_lead_status_history_lead ON lead_status_history(lead_id);
CREATE INDEX idx_campaign_lead_mapping_campaign ON campaign_lead_mapping(campaign_id);
```

---

## ğŸ”Œ EXISTING INFRASTRUCTURE MAPPING

### Live SignalHouse Integration

**SignalHouse is ALREADY configured and ready for 2K/day SMS blasts:**

| Component | Path | Status |
|-----------|------|--------|
| **SignalHouse Client** | [lib/signalhouse/client.ts](apps/front/src/lib/signalhouse/client.ts) | âœ… LIVE |
| **Bulk Send API** | [api/signalhouse/bulk-send/route.ts](apps/front/src/app/api/signalhouse/bulk-send/route.ts) | âœ… LIVE |
| **Campaign API** | [api/signalhouse/campaign/route.ts](apps/front/src/app/api/signalhouse/campaign/route.ts) | âœ… LIVE |
| **Webhook (Inbound)** | [api/webhook/signalhouse/route.ts](apps/front/src/app/api/webhook/signalhouse/route.ts) | âœ… LIVE |
| **SMS Queue Service** | [lib/services/sms-queue-service.ts](apps/front/src/lib/services/sms-queue-service.ts) | âœ… LIVE |

**Live Webhook URL**: `https://monkfish-app-mb7h3.ondigitalocean.app/api/webhook/signalhouse`

### GIANNA Inbound Response Center

**GIANNA is TRAINED and ready to copilot all inbound responses:**

| Component | Path | Purpose |
|-----------|------|---------|
| **Gianna Service** | [lib/gianna/gianna-service.ts](apps/front/src/lib/gianna/gianna-service.ts) | Unified AI engine |
| **Personality DNA** | [lib/gianna/personality-dna.ts](apps/front/src/lib/gianna/personality-dna.ts) | 8 personality archetypes |
| **Conversation Flows** | [lib/gianna/conversation-flows.ts](apps/front/src/lib/gianna/conversation-flows.ts) | 15+ conversation flows |
| **Message Library** | [lib/gianna/knowledge-base/message-library.ts](apps/front/src/lib/gianna/knowledge-base/message-library.ts) | 160+ templates |
| **Automation Flows** | [lib/gianna/knowledge-base/automation-flows.ts](apps/front/src/lib/gianna/knowledge-base/automation-flows.ts) | Email capture, calendar, voicemail |

**Existing OPENER_LIBRARY categories**: `property`, `business`, `general`, `ny_direct`

### LUCI Data Copilot

**LUCI fetches best data and creates leads through skip tracing:**

| Component | Path | Purpose |
|-----------|------|---------|
| **LUCI Pipeline** | [api/luci/pipeline/route.ts](apps/front/src/app/api/luci/pipeline/route.ts) | Full enrichment pipeline |
| **LUCI Campaigns** | [api/luci/campaigns/route.ts](apps/front/src/app/api/luci/campaigns/route.ts) | 2K per campaign type |
| **LUCI Push-to-SMS** | [api/luci/push-to-sms/route.ts](apps/front/src/app/api/luci/push-to-sms/route.ts) | Queue leads for SMS |
| **LUCI Batch** | [api/luci/batch/route.ts](apps/front/src/app/api/luci/batch/route.ts) | Batch processing |
| **LUCI Agent Config** | [config/agents/luci.ts](apps/front/src/config/agents/luci.ts) | Agent definition |

### SMS Queue System

| Component | Path | Purpose |
|-----------|------|---------|
| **SMS Queue API** | [api/sms/queue/route.ts](apps/front/src/app/api/sms/queue/route.ts) | Preview, approve, send |
| **SMS Batch** | [api/sms/batch/route.ts](apps/front/src/app/api/sms/batch/route.ts) | Batch operations |
| **Message Templates Page** | [app/t/[team]/message-templates/page.tsx](apps/front/src/app/t/[team]/message-templates/page.tsx) | Template management |

---

## ğŸš€ AUTOPILOT EXECUTION FLOW

### The Machine: PREP â†’ PREVIEW â†’ EXECUTE

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    EXPONENTIAL CAMPAIGN AUTOPILOT                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  PHASE 1: PREP (LUCI)                                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ USBizData   â”‚ â†’  â”‚ Skip Trace  â”‚ â†’  â”‚ Score &     â”‚ â†’  â”‚ Generate    â”‚   â”‚
â”‚  â”‚ Import      â”‚    â”‚ 2K Records  â”‚    â”‚ Tag Leads   â”‚    â”‚ Campaigns   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â”‚  API Endpoints:                                                              â”‚
â”‚  â€¢ POST /api/luci/pipeline    â†’ Full scan + skip trace                      â”‚
â”‚  â€¢ POST /api/luci/batch       â†’ Batch processing (100/batch, 2000 max)      â”‚
â”‚  â€¢ POST /api/luci/campaigns   â†’ Generate campaigns by type                   â”‚
â”‚                                                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  PHASE 2: PREVIEW (Human-in-Loop)                                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚  â”‚ View Queue  â”‚ â†’  â”‚ Edit/Swap   â”‚ â†’  â”‚ Approve     â”‚                      â”‚
â”‚  â”‚ (Draft)     â”‚    â”‚ Templates   â”‚    â”‚ Batch       â”‚                      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                                                                              â”‚
â”‚  API Endpoints:                                                              â”‚
â”‚  â€¢ GET  /api/sms/queue?action=preview    â†’ See pending messages             â”‚
â”‚  â€¢ POST /api/sms/queue {action: edit}    â†’ Modify before sending            â”‚
â”‚  â€¢ POST /api/sms/queue {action: approve} â†’ Move to approved queue           â”‚
â”‚                                                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  PHASE 3: EXECUTE (SignalHouse)                                              â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Bulk Send   â”‚ â†’  â”‚ Webhook     â”‚ â†’  â”‚ GIANNA AI   â”‚ â†’  â”‚ Response    â”‚   â”‚
â”‚  â”‚ via SH API  â”‚    â”‚ Receives    â”‚    â”‚ Processes   â”‚    â”‚ Logged      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â”‚  API Endpoints:                                                              â”‚
â”‚  â€¢ POST /api/signalhouse/bulk-send       â†’ Send approved batch              â”‚
â”‚  â€¢ POST /api/webhook/signalhouse         â†’ Receive inbound + status         â”‚
â”‚  â€¢ POST /api/gianna/respond              â†’ AI generates response            â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Autopilot Execution Command

```bash
# PREP: Scan data lake and generate campaigns
curl -X POST https://monkfish-app-mb7h3.ondigitalocean.app/api/luci/campaigns \
  -H "Content-Type: application/json" \
  -d '{
    "campaignType": "SMS_INITIAL",
    "maxRecords": 2000,
    "filters": {
      "revenueMin": 1000000,
      "revenueMax": 10000000,
      "tags": ["acquisition-target", "owner-identified"]
    }
  }'

# PREVIEW: Get queue for human review
curl "https://monkfish-app-mb7h3.ondigitalocean.app/api/sms/queue?action=preview&limit=50"

# EXECUTE: Send approved batch
curl -X POST https://monkfish-app-mb7h3.ondigitalocean.app/api/signalhouse/bulk-send \
  -H "Content-Type: application/json" \
  -d '{
    "to": ["phones from approved queue"],
    "message": "Template message with {firstName} personalization",
    "campaignId": "SMS-INITIAL-20251220-ABC123"
  }'
```

---

## ğŸ“± INITIAL SMS TEMPLATES BY PERSONA

### Existing Template Library Location
**File**: [lib/gianna/knowledge-base/message-library.ts](apps/front/src/lib/gianna/knowledge-base/message-library.ts)

### Business Broker Templates (ECBB Focus)

```typescript
// Add to OPENER_LIBRARY.business_broker in message-library.ts

export const BUSINESS_BROKER_OPENERS = [
  // Exit-Ready
  "{firstName}, I help owners of $1-10M businesses like {companyName} prep for exit. Ever thought about your number?",
  "Hey {firstName}, {companyName} looks like a solid operation. You know what it's worth to a buyer today?",
  "{firstName}, in {industry} right now - businesses like yours are getting 3-5x multiples. Curious what that means for {companyName}?",
  
  // Valuation Hook
  "{firstName}, free valuation for {companyName} - no strings. Just want to show you what buyers would pay.",
  "Hey {firstName}, most {industry} owners undervalue by 20-40%. Want to know your real number?",
  "{firstName}, I've helped 50+ {industry} owners see what they're actually sitting on. Your turn?",
  
  // Exit Planning
  "{firstName}, 80% of owners aren't exit-ready when buyers come calling. You one of them?",
  "Quick question {firstName} - if someone offered you 3x revenue for {companyName} tomorrow, could you close?",
  "{firstName}, exit prep takes 12-18 months. The time to start is before you need to. Chat?",
];
```

### Real Estate Agent/Broker Templates

```typescript
export const REAL_ESTATE_BROKER_OPENERS = [
  // Off-Market Hook
  "{firstName}, I source off-market deals for agents who want proprietary inventory. Interested?",
  "Hey {firstName}, your competitors are getting deals before they hit MLS. Want in?",
  "{firstName}, I've got 50+ pocket listings in {city}. Want first look?",
  
  // AI Angle
  "{firstName}, AI is changing how top agents find deals. 15 mins to show you?",
  "Hey {firstName}, what if AI found you 10 new listings/month? That's what we do.",
  "{firstName}, the agents crushing it in 2025 are using AI for lead gen. You using it yet?",
  
  // Investor Focus
  "{firstName}, I connect agents with investors who close fast. Need more buyers?",
  "Hey {firstName}, your investor buyers need more inventory. I can help with that.",
  "{firstName}, off-market + AI + investor network = more closings. Quick chat?",
];
```

### Private Equity / Roll-Up Templates

```typescript
export const PRIVATE_EQUITY_OPENERS = [
  // Deal Flow Hook
  "{firstName}, I source proprietary deal flow in {industry}. 100+ businesses/month. Interested?",
  "Hey {firstName}, looking for add-ons in {industry}? I've got a pipeline.",
  "{firstName}, we use AI to find acquisition targets before they hit market. Quick chat?",
  
  // Platform Play
  "{firstName}, building a {industry} platform? I can feed you 50 targets/week.",
  "Hey {firstName}, consolidation in {industry} is heating up. Want first-mover access?",
  "{firstName}, our AI identifies exit-ready owners in {industry}. Your next add-on is in there.",
  
  // Data Advantage
  "{firstName}, we've mapped 2M+ businesses with owner data. {industry} is your focus?",
  "Hey {firstName}, skip-traced owner mobiles + exit signals = your unfair advantage. 15 mins?",
  "{firstName}, proprietary data + AI outreach = deals your competitors never see. Interested?",
];
```

### Consultant / M&A Advisor Templates

```typescript
export const CONSULTANT_OPENERS = [
  // AI Audit Hook
  "{firstName}, I help consultants like you offer AI audits to clients. New revenue stream. Interested?",
  "Hey {firstName}, your clients are asking about AI. I can white-label a full AI audit for you.",
  "{firstName}, AI blueprints + mindmaps = $10K+ engagements. Want to add this to your practice?",
  
  // Exit Prep
  "{firstName}, I help M&A advisors with pre-exit prep. Makes your deals close faster. Chat?",
  "Hey {firstName}, the best deals are prepped 12 months before listing. I can help you do that.",
  "{firstName}, technology integration + exit prep = higher multiples for your clients. 15 mins?",
  
  // Lead Gen
  "{firstName}, what if you had 100 warm leads/month from business owners ready to talk? That's what we do.",
  "Hey {firstName}, I source owners who are 12-24 months from exit. Your ideal clients?",
  "{firstName}, stop chasing. Let AI bring you qualified sellers. Quick demo?",
];
```

---

## ğŸ”„ GTM: SELLING TO OTHER SALESPEOPLE

### The Pitch: "We Built This For Ourselves - Now You Can Use It"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         GTM POSITIONING                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  STORY: "We're East Coast Business Brokers. We built this machine           â”‚
â”‚          to source our own deals. Now we're licensing it to you."           â”‚
â”‚                                                                              â”‚
â”‚  PROOF: "We send 2K SMS/day internally. Our AI handles all inbound.         â”‚
â”‚          We're proving it works before selling it."                          â”‚
â”‚                                                                              â”‚
â”‚  OFFER: "Same infrastructure. Your brand. Your leads. Your deals."          â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Demo Flow for Prospects

1. **Show LUCI Dashboard** â†’ "This is where the data comes in. 2M+ businesses."
2. **Show Skip Trace** â†’ "We find the owner's mobile. Not the office number."
3. **Show Campaign Prep** â†’ "2,000 leads per campaign. Preview before sending."
4. **Show SignalHouse Blast** â†’ "One click. 2K messages. Done."
5. **Show GIANNA Inbound** â†’ "AI responds to every reply. You only see qualified."
6. **Show Deal Pipeline** â†’ "From cold list to signed listing. All tracked."

### Pricing Tiers (Internal Reference)

| Tier | Monthly | SMS/Day | Features |
|------|---------|---------|----------|
| **Starter** | $497 | 500 | LUCI + GIANNA + Basic templates |
| **Growth** | $997 | 2,000 | All agents + Custom templates |
| **Enterprise** | $2,497 | 5,000 | White-label + API access |

---

### LUCI Event-Driven Controller

```typescript
// lib/luci-ai-agent.ts

import { EventEmitter } from 'events';
import { DatabaseService } from './database-service';
import { SkipTraceOrchestrator } from './skip-trace-orchestrator';
import { LeadQueueManager } from './lead-queue-manager';

export class LuciAI extends EventEmitter {
  private dbService: DatabaseService;
  private skipTraceOrchestrator: SkipTraceOrchestrator;
  private queueManager: LeadQueueManager;
  private activeSession: LuciSession | null = null;
  
  constructor() {
    super();
    this.dbService = new DatabaseService();
    this.skipTraceOrchestrator = new SkipTraceOrchestrator();
    this.queueManager = new LeadQueueManager();
    this.setupEventListeners();
  }
  
  private setupEventListeners() {
    // Listen for USBizData import events
    this.on('USBIZDATA_IMPORTED', this.handleUSBizDataImport.bind(this));
    this.on('SKIP_TRACE_COMPLETED', this.handleSkipTraceCompletion.bind(this));
    this.on('LEAD_QUEUE_READY', this.handleLeadQueueReady.bind(this));
  }
  
  async handleUSBizDataImport(eventData: USBizDataImportEvent): Promise<void> {
    console.log('ğŸ”„ LUCI ACTIVATED: Processing USBizData import event');
    
    try {
      // Create new LUCI session
      const session = await this.createLuciSession(eventData);
      this.activeSession = session;
      
      // Emit activation event
      this.emit('LUCI_ACTIVATED', {
        sessionId: session.id,
        eventId: eventData.eventId,
        totalRecords: eventData.totalRecords
      });
      
      // Start data processing pipeline
      await this.processUSBizDataRecords(session, eventData.records);
      
    } catch (error) {
      console.error('LUCI processing failed:', error);
      this.emit('LUCI_PROCESSING_FAILED', { error: error.message });
    }
  }
  
  private async createLuciSession(eventData: USBizDataImportEvent): Promise<LuciSession> {
    const session = await this.dbService.createLuciSession({
      session_name: `LUCI Session - ${new Date().toISOString()}`,
      trigger_event_id: eventData.eventId,
      total_records: eventData.totalRecords,
      processing_strategy: {
        skipTraceEnabled: true,
        qualityScoringEnabled: true,
        autoQueueEnabled: true,
        maxConcurrentProcessing: 4,
        batchSize: 250,
        qualityThresholds: {
          minQualityScore: 60,
          minPriorityScore: 40
        },
        targetSegments: this.analyzeSegments(eventData.records)
      }
    });
    
    return session;
  }
  
  private async processUSBizDataRecords(session: LuciSession, records: any[]): Promise<void> {
    console.log(`ğŸ¤– LUCI: Processing ${records.length} records with skip trace up to 2,000`);
    
    try {
      // Limit processing to 2,000 records as specified
      const limitedRecords = records.slice(0, 2000);
      
      // Create lead records for all processed data
      const leadPromises = limitedRecords.map(record => 
        this.createLeadRecord(session, record)
      );
      
      const leads = await Promise.all(leadPromises);
      await this.dbService.updateLuciSessionProgress(session.id, {
        processed_records: leads.length
      });
      
      console.log(`ğŸ¤– LUCI: Created ${leads.length} lead records`);
      
      // Execute skip tracing on leads
      if (session.skip_trace_enabled) {
        await this.executeSkipTraceOnLeads(session, leads);
      }
      
      // Score and analyze leads
      if (session.lead_scoring_enabled) {
        await this.scoreAndAnalyzeLeads(session, leads);
      }
      
      // Queue leads for assignment
      if (session.auto_queue_enabled) {
        await this.queueLeadsForAssignment(session, leads);
      }
      
      // Complete session
      await this.completeLuciSession(session.id);
      
    } catch (error) {
      console.error('LUCI record processing failed:', error);
      throw error;
    }
  }
  
  private async createLeadRecord(session: LuciSession, record: any): Promise<LeadRecord> {
    // Generate persistent LeadID
    const leadId = await this.generateLeadId();
    
    const lead = await this.dbService.createLeadMaster({
      lead_id: leadId,
      record_id: record.id,
      luci_session_id: session.id,
      business_name: record.business_name,
      owner_name: record.owner_name || this.extractOwnerName(record),
      owner_title: record.owner_title,
      primary_phone: record.business_phone,
      mobile_phone: record.mobile_phone,
      business_email: record.business_email,
      website: record.website,
      industry: record.industry,
      revenue_range: this.categorizeRevenue(record.annual_revenue),
      employee_count: record.employee_count,
      address: record.business_address,
      city: record.city,
      state: record.state,
      zip_code: record.zip_code,
      lead_source: 'usbizdata',
      acquisition_channel: 'luci_ai_processing',
      current_status: 'new',
      assigned_agent: 'luci', // LUCI initially owns the lead
      first_contact_at: new Date()
    });
    
    return lead;
  }
  
  private async executeSkipTraceOnLeads(session: LuciSession, leads: LeadRecord[]): Promise<void> {
    console.log('ğŸ¤– LUCI: Executing skip trace on leads...');
    
    try {
      // Process skip tracing for leads that don't have owner info
      const leadsNeedingTrace = leads.filter(lead => !lead.owner_name);
      
      if (leadsNeedingTrace.length === 0) {
        console.log('ğŸ¤– LUCI: All leads already have owner information');
        return;
      }
      
      // Convert leads to skip trace format
      const skipTraceJobs = leadsNeedingTrace.map(lead => ({
        business_id: lead.record_id,
        business_name: lead.business_name,
        business_address: lead.address,
        city: lead.city,
        state: lead.state,
        zip_code: lead.zip_code
      }));
      
      // Execute skip trace workflow
      const skipTraceResult = await this.skipTraceOrchestrator.executeSkipTraceJobs(skipTraceJobs);
      
      // Update leads with skip trace results
      for (const result of skipTraceResult.results) {
        if (result.found && result.contact) {
          await this.dbService.updateLeadOwnerInfo(result.businessId, {
            owner_name: result.contact.owner_full_name,
            owner_title: result.contact.owner_title,
            primary_phone: result.contact.primary_phone,
            mobile_phone: result.contact.mobile_phone,
            email: result.contact.email
          });
        }
      }
      
      await this.dbService.updateLuciSessionProgress(session.id, {
        skip_traced_records: skipTraceResult.found
      });
      
      console.log(`ğŸ¤– LUCI: Skip trace completed - found ${skipTraceResult.found} owners`);
      
    } catch (error) {
      console.error('LUCI skip trace failed:', error);
      throw error;
    }
  }
  
  private async scoreAndAnalyzeLeads(session: LuciSession, leads: LeadRecord[]): Promise<void> {
    console.log('ğŸ¤– LUCI: Scoring and analyzing leads...');
    
    for (const lead of leads) {
      try {
        // LUCI AI scoring algorithm
        const qualityScore = await this.calculateQualityScore(lead);
        const priorityLevel = await this.calculatePriorityLevel(lead, qualityScore);
        
        // Update lead with LUCI analysis
        await this.dbService.updateLeadAnalysis(lead.id, {
          quality_score: qualityScore,
          priority_level: priorityLevel,
          acquisition_channel: 'luci_ai_scored',
          updated_at: new Date()
        });
        
      } catch (error) {
        console.error(`Failed to score lead ${lead.id}:`, error);
      }
    }
    
    console.log(`ğŸ¤– LUCI: Completed scoring for ${leads.length} leads`);
  }
  
  private async queueLeadsForAssignment(session: LuciSession, leads: LeadRecord[]): Promise<void> {
    console.log('ğŸ¤– LUCI: Queueing leads for assignment...');
    
    // Filter leads based on quality thresholds
    const qualifiedLeads = leads.filter(lead => 
      lead.quality_score >= 60 && lead.priority_level >= 40
    );
    
    if (qualifiedLeads.length === 0) {
      console.log('ğŸ¤– LUCI: No leads meet quality thresholds for queuing');
      return;
    }
    
    // Create queue entries
    const queuePromises = qualifiedLeads.map(lead => 
      this.queueManager.enqueueLead(lead, {
        queue_name: this.determineQueue(lead),
        priority_score: lead.priority_level,
        recommended_action: this.recommendAction(lead),
        suggested_timing: this.calculateOptimalTiming(lead),
        quality_flags: this.extractQualityFlags(lead)
      })
    );
    
    await Promise.all(queuePromises);
    
    await this.dbService.updateLuciSessionProgress(session.id, {
      queued_leads: qualifiedLeads.length
    });
    
    console.log(`ğŸ¤– LUCI: Queued ${qualifiedLeads.length} leads for assignment`);
    
    // Emit queue ready event
    this.emit('LEAD_QUEUE_READY', {
      sessionId: session.id,
      queuedLeads: qualifiedLeads.length,
      leads: qualifiedLeads
    });
  }
  
  private async calculateQualityScore(lead: LeadRecord): Promise<number> {
    let score = 50; // Base score
    
    // Industry scoring
    const highValueIndustries = ['technology', 'healthcare', 'finance', 'manufacturing'];
    if (highValueIndustries.includes(lead.industry?.toLowerCase())) {
      score += 20;
    }
    
    // Revenue scoring
    if (lead.revenue_range) {
      {
        'under const revenueRanges =_1m': 0,
        '1m_5m': 10,
        '5m_10m': 20,
        '10m_50m': 30,
        'over_50m': 40
      };
      score += revenueRanges[lead.revenue_range] || 0;
    }
    
    // Employee count scoring
    if (lead.employee_count) {
      if (lead.employee_count >= 50) score += 15;
      else if (lead.employee_count >= 20) score += 10;
      else if (lead.employee_count >= 10) score += 5;
    }
    
    // Contact information completeness
    let contactScore = 0;
    if (lead.primary_phone) contactScore += 5;
    if (lead.mobile_phone) contactScore += 10;
    if (lead.business_email) contactScore += 5;
    if (lead.owner_name) contactScore += 10;
    
    score += Math.min(contactScore, 20);
    
    return Math.min(score, 100);
  }
  
  private async calculatePriorityLevel(lead: LeadRecord, qualityScore: number): Promise<number> {
    let priority = qualityScore;
    
    // Boost priority for certain conditions
    if (lead.industry?.toLowerCase().includes('real estate')) priority += 10;
    if (lead.employee_count && lead.employee_count > 100) priority += 15;
    if (lead.revenue_range === 'over_50m') priority += 20;
    
    return Math.min(priority, 100);
  }
  
  private determineQueue(lead: LeadRecord): string {
    if (lead.priority_level >= 80) return 'high_priority';
    if (lead.priority_level >= 60) return 'standard';
    return 'follow_up';
  }
  
  private recommendAction(lead: LeadRecord): string {
    if (!lead.owner_name) return 'skip_trace_required';
    if (!lead.mobile_phone) return 'phone_validation_required';
    if (lead.priority_level >= 80) return 'immediate_outreach';
    return 'standard_outreach';
  }
  
  private calculateOptimalTiming(lead: LeadRecord): Date {
    const now = new Date();
    const businessHours = this.isBusinessHours(lead.state);
    
    if (businessHours) {
      return new Date(now.getTime() + 30 * 60 * 1000); // 30 minutes
    } else {
      return new Date(now.getTime() + 2 * 60 * 60 * 1000); // 2 hours
    }
  }
  
  private extractQualityFlags(lead: LeadRecord): any {
    const flags = [];
    
    if (!lead.owner_name) flags.push('missing_owner');
    if (!lead.mobile_phone) flags.push('missing_mobile');
    if (lead.priority_level >= 80) flags.push('high_priority');
    if (lead.industry?.toLowerCase().includes('real estate')) flags.push('real_estate');
    
    return { flags, reasons: flags.map(f => `Lead flagged: ${f}`) };
  }
  
  private async generateLeadId(): Promise<string> {
    const year = new Date().getFullYear();
    const sequence = await this.dbService.getNextLeadSequence();
    return `LEAD-${year}-${sequence.toString().padStart(6, '0')}`;
  }
  
  private analyzeSegments(records: any[]): any {
    const segments = {};
    
    for (const record of records) {
      const industry = record.industry?.toLowerCase() || 'unknown';
      if (!segments[industry]) {
        segments[industry] = { count: 0, totalRevenue: 0 };
      }
      segments[industry].count++;
      segments[industry].totalRevenue += record.annual_revenue || 0;
    }
    
    return segments;
  }
  
  private categorizeRevenue(revenue: number): string {
    if (!revenue) return 'unknown';
    if (revenue < 1000000) return 'under_1m';
    if (revenue < 5000000) return '1m_5m';
    if (revenue < 10000000) return '5m_10m';
    if (revenue < 50000000) return '10m_50m';
    return 'over_50m';
  }
  
  private extractOwnerName(record: any): string | null {
    // Try to extract owner name from various fields
    return record.contact_name || record.owner_name || null;
  }
  
  private isBusinessHours(state: string): boolean {
    // Simplified business hours check based on timezone
    const easternStates = ['FL', 'NY', 'PA', 'OH', 'MI', 'GA', 'NC', 'NJ', 'VA', 'WA'];
    return easternStates.includes(state?.toUpperCase());
  }
  
  private async completeLuciSession(sessionId: string): Promise<void> {
    await this.dbService.updateLuciSession(sessionId, {
      status: 'completed',
      completed_at: new Date()
    });
    
    console.log('ğŸ¤– LUCI: Session completed successfully');
  }
  
  // Event Handlers
  private async handleSkipTraceCompletion(eventData: any): Promise<void> {
    console.log('ğŸ“ LUCI: Skip trace completed, updating lead information...');
    // Update leads with skip trace results
  }
  
  private async handleLeadQueueReady(eventData: any): Promise<void> {
    console.log('ğŸ¯ LUCI: Lead queue ready, triggering assignment...');
    // Trigger lead assignment workflow
  }
}

// Interfaces
interface USBizDataImportEvent {
  eventId: string;
  totalRecords: number;
  records: any[];
}

interface LuciSession {
  id: string;
  session_name: string;
  status: string;
  total_records: number;
  skip_trace_enabled: boolean;
  lead_scoring_enabled: boolean;
  auto_queue_enabled: boolean;
}

interface LeadRecord {
  id: string;
  lead_id: string;
  record_id: string;
  business_name: string;
  owner_name?: string;
  primary_phone?: string;
  mobile_phone?: string;
  industry?: string;
  revenue_range?: string;
  employee_count?: number;
  quality_score?: number;
  priority_level?: number;
}
```

---

## ğŸ“Š LEAD QUEUE MANAGER

### Lead Assignment System

```typescript
// lib/lead-queue-manager.ts

import { DatabaseService } from './database-service';
import { EventEmitter } from 'events';

export class LeadQueueManager extends EventEmitter {
  private dbService: DatabaseService;
  
  constructor() {
    super();
    this.dbService = new DatabaseService();
    this.setupEventListeners();
  }
  
  private setupEventListeners() {
    this.on('LEAD_ASSIGNED', this.handleLeadAssigned.bind(this));
    this.on('ASSIGNMENT_COMPLETED', this.handleAssignmentCompleted.bind(this));
  }
  
  async enqueueLead(lead: LeadRecord, queueConfig: QueueConfig): Promise<void> {
    console.log(`ğŸ¯ Queueing lead ${lead.lead_id} for assignment...`);
    
    try {
      // Create queue entry
      const queueEntry = await this.dbService.createQueueEntry({
        lead_id: lead.id,
        queue_name: queueConfig.queue_name,
        priority_score: queueConfig.priority_score,
        recommended_action: queueConfig.recommended_action,
        suggested_timing: queueConfig.suggested_timing,
        quality_flags: queueConfig.quality_flags
      });
      
      // Generate assignment ID
      const assignmentId = await this.generateAssignmentId();
      
      // Create assignment record
      const assignment = await this.dbService.createLeadAssignment({
        assignment_id: assignmentId,
        lead_id: lead.id,
        assigned_agent: this.selectOptimalAgent(lead),
        assignment_type: this.determineAssignmentType(lead),
        assignment_reason: `LUCI queued lead for ${queueConfig.recommended_action}`,
        priority_level: queueConfig.priority_score,
        due_date: queueConfig.suggested_timing,
        assignment_context: {
          quality_score: lead.quality_score,
          business_name: lead.business_name,
          industry: lead.industry,
          recommended_action: queueConfig.recommended_action,
          queue_entry_id: queueEntry.id
        }
      });
      
      // Link queue entry to assignment
      await this.dbService.updateQueueEntry(queueEntry.id, {
        assignment_id: assignment.id,
        queue_status: 'assigned'
      });
      
      // Update lead with assignment info
      await this.dbService.updateLead(lead.id, {
        assigned_agent: assignment.assigned_agent,
        assigned_at: new Date(),
        assignment_reason: assignment.assignment_reason,
        status_updated_at: new Date()
      });
      
      console.log(`âœ… Lead ${lead.lead_id} assigned to ${assignment.assigned_agent}`);
      
      // Emit assignment event
      this.emit('LEAD_ASSIGNED', {
        leadId: lead.id,
        leadId: lead.lead_id,
        assignmentId: assignment.id,
        assignedAgent: assignment.assigned_agent,
        priorityLevel: assignment.priority_level
      });
      
    } catch (error) {
      console.error('Failed to queue lead:', error);
      throw error;
    }
  }
  
  private selectOptimalAgent(lead: LeadRecord): string {
    // LUCI's intelligent agent selection logic
    const agentCapabilities = {
      'gianna': { industries: ['real_estate', 'retail'], priorityRange: [40, 70] },
      'cathy': { industries: ['technology', 'manufacturing'], priorityRange: [50, 80] },
      'sabrina': { industries: ['finance', 'healthcare'], priorityRange: [70, 100] },
      'neva': { industries: ['all'], priorityRange: [30, 60] }
    };
    
    // Score each agent for this lead
    const agentScores = Object.entries(agentCapabilities).map(([agent, capabilities]) => {
      let score = 0;
      
      // Industry match
      if (capabilities.industries.includes('all') || 
          capabilities.industries.some(ind => lead.industry?.toLowerCase().includes(ind))) {
        score += 30;
      }
      
 match
      if      // Priority range (lead.priority_level >= capabilities.priorityRange[0] && 
          lead.priority_level <= capabilities.priorityRange[1]) {
        score += 40;
      }
      
      // Special conditions
      if (lead.priority_level >= 80 && agent === 'sabrina') score += 20; // High-priority to Sabrina
      if (!lead.owner_name && agent === 'neva') score += 15; // Research tasks to Neva
      
      return { agent, score };
    });
    
    // Return highest scoring agent
    const bestAgent = agentScores.reduce((best, current) => 
      current.score > best.score ? current : best
    );
    
    return bestAgent.agent;
  }
  
  private determineAssignmentType(lead: LeadRecord): string {
    if (lead.priority_level >= 80) return 'immediate_outreach';
    if (!lead.owner_name) return 'owner_research';
    if (!lead.mobile_phone) return 'phone_validation';
    return 'standard_outreach';
  }
  
  private async generateAssignmentId(): Promise<string> {
    const year = new Date().getFullYear();
    const sequence = await this.dbService.getNextAssignmentSequence();
    return `ASSIGN-${year}-${sequence.toString().padStart(6, '0')}`;
  }
  
  // Event Handlers
  private async handleLeadAssigned(eventData: any): Promise<void> {
    console.log(`ğŸ“‹ Assignment created: ${eventData.assignmentId}`);
    // Trigger SMS campaign initiation if appropriate
    await this.initiateSMSCampaignForLead(eventData.leadId);
  }
  
  private async handleAssignmentCompleted(eventData: any): Promise<void> {
    console.log(`âœ… Assignment completed: ${eventData.assignmentId}`);
    // Update lead status and trigger next steps
  }
  
  private async initiateSMSCampaignForLead(leadId: string): Promise<void> {
    try {
      const lead = await this.dbService.getLeadById(leadId);
      
      if (lead && lead.mobile_phone && lead.priority_level >= 50) {
        // Create targeted SMS campaign for this lead
        const campaign = await this.dbService.createSMSCampaign({
          campaign_name: `Lead Outreach - ${lead.business_name}`,
          campaign_type: 'lead_outreach',
          target_segment: lead.industry,
          template_id: await this.selectOptimalTemplate(lead),
          sender_phone: await this.selectOptimalSender(lead),
          max_recipients: 1,
          min_priority_score: lead.priority_level
        });
        
        console.log(`ğŸ“± SMS campaign created for lead ${lead.lead_id}`);
      }
    } catch (error) {
      console.error('Failed to initiate SMS campaign:', error);
    }
  }
  
  private async selectOptimalTemplate(lead: LeadRecord): Promise<string> {
    // Template selection logic based on lead characteristics
    const templates = {
      'real_estate': 'real_estate_outreach_template',
      'technology': 'tech_business_template',
      'healthcare': 'healthcare_business_template',
      'default': 'general_business_template'
    };
    
    const industry = lead.industry?.toLowerCase() || '';
    for (const [key, template] of Object.entries(templates)) {
      if (industry.includes(key)) {
        return template;
      }
    }
    
    return templates.default;
  }
  
  private async selectOptimalSender(lead: LeadRecord): Promise<string> {
    // Select optimal sender based on lead characteristics
    const senderPool = [
      '+1234567890', // Gianna
      '+1234567891', // Cathy
      '+1234567892', // Sabrina
      '+1234567893'  // Neva
    ];
    
    // Return sender based on agent assignment
    const agentSenders = {
      'gianna': senderPool[0],
      'cathy': senderPool[1],
      'sabrina': senderPool[2],
      'neva': senderPool[3]
    };
    
    return agentSenders[lead.assigned_agent] || senderPool[0];
  }
}

interface QueueConfig {
  queue_name: string;
  priority_score: number;
  recommended_action: string;
  suggested_timing: Date;
  quality_flags: any;
}
```

---

## ğŸ“± SMS CAMPAIGN INTEGRATION

### Campaign-Lead Relationship Management

```typescript
// lib/sms-campaign-integration.ts

import { DatabaseService } from './database-service';
import { TwilioService } from './twilio-service';

export class SMSCampaignIntegration {
  private dbService: DatabaseService;
  private twilioService: TwilioService;
  
  constructor() {
    this.dbService = new DatabaseService();
    this.twilioService = new TwilioService();
  }
  
  async createCampaignForLead(leadId: string, campaignConfig: CampaignConfig): Promise<CampaignResult> {
    console.log(`ğŸ“± Creating SMS campaign for lead ${leadId}`);
    
    try {
      // Get lead details
      const lead = await this.dbService.getLeadById(leadId);
      if (!lead || !lead.mobile_phone) {
        throw new Error('Lead not found or mobile phone not available');
      }
      
      // Create campaign record
      const campaign = await this.dbService.createSMSCampaign({
        campaign_name: `Lead Outreach - ${lead.business_name}`,
        campaign_type: 'lead_outreach',
        target_segment: lead.industry || 'general',
        template_id: campaignConfig.templateId,
        sender_phone: campaignConfig.senderPhone,
        message_content: this.personalizeMessage(campaignConfig.messageTemplate, lead),
        batch_size: 1,
        scheduled_start: new Date(),
        total_targeted: 1
      });
      
      // Create campaign-lead mapping
      await this.dbService.createCampaignLeadMapping({
        campaign_id: campaign.id,
        lead_id: lead.id,
        lead_position: 1,
        targeting_criteria: {
          lead_id: lead.id,
          business_name: lead.business_name,
          industry: lead.industry,
          priority_level: lead.priority_level
        },
        personalization_data: {
          owner_name: lead.owner_name,
          business_name: lead.business_name,
          industry: lead.industry,
          city: lead.city,
          state: lead.state
        }
      });
      
      // Create communication thread
      const thread = await this.dbService.createCommunicationThread({
        thread_id: await this.generateThreadId(),
        lead_id: lead.id,
        campaign_id: campaign.id,
        thread_type: 'sms',
        communication_channel: 'sms',
        thread_subject: `SMS Outreach - ${lead.business_name}`,
        initial_message: campaign.message_content,
        thread_context: {
          campaign_id: campaign.id,
          lead_id: lead.id,
          template_used: campaignConfig.templateId
        }
      });
      
      // Send initial SMS
      const smsResult = await this.sendInitialSMS(campaign, lead, thread);
      
      // Log communication event
      await this.logCommunicationEvent({
        event_type: 'sms_sent',
        event_subtype: 'initial_outreach',
        lead_id: lead.id,
        thread_id: thread.id,
        campaign_id: campaign.id,
        message_content: campaign.message_content,
        message_direction: 'outbound',
        delivery_status: smsResult.status,
        external_id: smsResult.messageSid,
        event_timestamp: new Date()
      });
      
      // Update lead status
      await this.dbService.updateLead(lead.id, {
        current_status: 'contacted',
        status_updated_at: new Date(),
        last_activity_at: new Date()
      });
      
      // Add to status history
      await this.dbService.addStatusHistory({
        lead_id: lead.id,
        from_status: 'new',
        to_status: 'contacted',
        status_changed_at: new Date(),
        changed_by: 'sms_campaign_system',
        change_reason: 'Initial SMS campaign sent',
        conversion_probability: lead.priority_level / 100
      });
      
      return {
        success: true,
        campaignId: campaign.id,
        threadId: thread.id,
        messageSid: smsResult.messageSid,
        leadStatus: 'contacted'
      };
      
    } catch (error) {
      console.error('SMS campaign creation failed:', error);
      throw error;
    }
  }
  
  private async sendInitialSMS(campaign: any, lead: any, thread: any): Promise<{ messageSid: string; status: string }> {
    const message = {
      to: lead.mobile_phone,
      from: campaign.sender_phone,
      body: campaign.message_content
    };
    
    return await this.twilioService.sendSMS(message);
  }
  
  private personalizeMessage(template: string, lead: any): string {
    let message = template;
    
    // Replace placeholders with lead data
    const placeholders = {
      '{{owner_name}}': lead.owner_name || 'there',
      '{{business_name}}': lead.business_name || 'your business',
      '{{industry}}': lead.industry || 'your industry',
      '{{city}}': lead.city || '',
      '{{state}}': lead.state || ''
    };
    
    for (const [placeholder, value] of Object.entries(placeholders)) {
      message = message.replace(new RegExp(placeholder, 'g'), value);
    }
    
    return message;
  }
  
  private async generateThreadId(): Promise<string> {
    const year = new Date().getFullYear();
    const sequence = await this.dbService.getNextThreadSequence();
    return `THREAD-${year}-${sequence.toString().padStart(6, '0')}`;
  }
  
  private async logCommunicationEvent(eventData: any): Promise<void> {
    const eventId = await this.generateEventId();
    
    await this.dbService.createCommunicationEvent({
      event_id: eventId,
      ...eventData
    });
  }
  
  private async generateEventId(): Promise<string> {
    const year = new Date().getFullYear();
    const sequence = await this.dbService.getNextEventSequence();
    return `EVENT-${year}-${sequence.toString().padStart(6, '0')}`;
  }
  
  // Response Handling
  async handleSMSResponse(messageSid: string, responseData: any): Promise<void> {
    console.log(`ğŸ“ Handling SMS response: ${messageSid}`);
    
    try {
      // Get communication event by message SID
      const event = await this.dbService.getCommunicationEventByMessageSid(messageSid);
      if (!event) {
        console.warn('Communication event not found for message SID:', messageSid);
        return;
      }
      
      // Log response event
      await this.logCommunicationEvent({
        event_type: 'sms_received',
        event_subtype: 'response',
        lead_id: event.lead_id,
        thread_id: event.thread_id,
        campaign_id: event.campaign_id,
        message_content: responseData.body,
        message_direction: 'inbound',
        delivery_status: 'received',
        event_timestamp: new Date(responseData.dateCreated),
        external_id: responseData.sid,
        technical_metadata: {
          twilio_data: responseData
        }
      });
      
      // Update thread last message time
      await this.dbService.updateCommunicationThread(event.thread_id, {
        last_message_at: new Date(responseData.dateCreated)
      });
      
      // Update lead status if first response
      await this.handleLeadResponse(event.lead_id, responseData);
      
    } catch (error) {
      console.error('Failed to handle SMS response:', error);
    }
  }
  
  private async handleLeadResponse(leadId: string, responseData: any): Promise<void> {
    const lead = await this.dbService.getLeadById(leadId);
    if (!lead) return;
    
    let newStatus = lead.current_status;
    let changeReason = 'SMS response received';
    
    // Status progression logic
    if (lead.current_status === 'contacted') {
      newStatus = 'engaged';
    } else if (lead.current_status === 'engaged') {
      newStatus = 'qualified';
    }
    
    if (newStatus !== lead.current_status) {
      await this.dbService.updateLead(leadId, {
        current_status: newStatus,
        status_updated_at: new Date(),
        last_activity_at: new Date()
      });
      
      await this.dbService.addStatusHistory({
        lead_id: leadId,
        from_status: lead.current_status,
        to_status: newStatus,
        status_changed_at: new Date(),
        changed_by: 'sms_response_system',
        change_reason: changeReason,
        conversion_probability: this.calculateConversionProbability(newStatus)
      });
    }
  }
  
  private calculateConversionProbability(status: string): number {
    const probabilities = {
      'new': 0.1,
      'contacted': 0.2,
      'engaged': 0.4,
      'qualified': 0.6,
      'proposal': 0.8,
      'closed': 1.0
    };
    
    return probabilities[status] || 0.1;
  }
}

interface CampaignConfig {
  templateId: string;
  senderPhone: string;
  messageTemplate: string;
}

interface CampaignResult {
  success: boolean;
  campaignId: string;
  threadId: string;
  messageSid: string;
  leadStatus: string;
}
```

---

## ğŸ“Š REAL-TIME ANALYTICS DASHBOARD

### Lead Lifecycle Tracking

```typescript
// components/LeadManagementDashboard.tsx

import React, { useState, useEffect } from 'react';

export function LeadManagementDashboard() {
  const [leadMetrics, setLeadMetrics] = useState<LeadMetrics | null>(null);
  const [activeLeads, setActiveLeads] = useState<LeadRecord[]>([]);
  const [campaignPerformance, setCampaignPerformance] = useState<CampaignMetrics[]>([]);
  const [luciActivity, setLuciActivity] = useState<LuciActivity | null>(null);
  
  useEffect(() => {
    // Initialize WebSocket for real-time updates
    const ws = new WebSocket(process.env.NEXT_PUBLIC_WS_URL + '/leads');
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      handleRealTimeUpdate(data);
    };
    
    fetchDashboardData();
    
    return () => ws.close();
  }, []);
  
  const fetchDashboardData = async () => {
    try {
      const [leadsResponse, metricsResponse, campaignsResponse, luciResponse] = await Promise.all([
        fetch('/api/leads/active'),
        fetch('/api/leads/metrics'),
        fetch('/api/campaigns/performance'),
        fetch('/api/luci/activity')
      ]);
      
      setActiveLeads(await leadsResponse.json());
      setLeadMetrics(await metricsResponse.json());
      setCampaignPerformance(await campaignsResponse.json());
      setLuciActivity(await luciResponse.json());
    } catch (error) {
      console.error('Failed to fetch dashboard data:', error);
    }
  };
  
  const handleRealTimeUpdate = (data: any) => {
    switch (data.type) {
      case 'NEW_LEAD_CREATED':
        setActiveLeads(prev => [data.lead, ...prev]);
        break;
      case 'LEAD_STATUS_CHANGED':
        setActiveLeads(prev => 
          prev.map(lead => 
            lead.id === data.leadId 
              ? { ...lead, current_status: data.newStatus }
              : lead
          )
        );
        break;
      case 'LUCI_SESSION_UPDATE':
        setLuciActivity(data.session);
        break;
      case 'SMS_CAMPAIGN_SENT':
        updateCampaignMetrics(data.campaignId);
        break;
    }
  };
  
  return (
    <div className="lead-management-dashboard">
      <div className="dashboard-header">
        <h1>ğŸ¯ Lead Management Center</h1>
        <div className="status-overview">
          <StatusCard 
            title="Active Leads" 
            value={leadMetrics?.totalActiveLeads || 0}
            icon="ğŸ‘¥"
            trend={leadMetrics?.leadsTrend || 0}
          />
          <StatusCard 
            title="LUCI Sessions" 
            value={luciActivity?.activeSessions || 0}
            icon="ğŸ¤–"
            trend={luciActivity?.sessionsTrend || 0}
          />
          <StatusCard 
            title="SMS Sent Today" 
            value={leadMetrics?.smsSentToday || 0}
            icon="ğŸ“±"
            trend={leadMetrics?.smsTrend || 0}
          />
          <StatusCard 
            title="Response Rate" 
            value={`${leadMetrics?.responseRate || 0}%`}
            icon="ğŸ“ˆ"
            trend={leadMetrics?.responseTrend || 0}
          />
        </div>
      </div>
      
      <div className="dashboard-grid">
        {/* LUCI Activity Panel */}
        <div className="dashboard-panel">
          <h3>ğŸ¤– LUCI AI Activity</h3>
          {luciActivity && (
            <div className="luci-status">
              <div className="status-item">
                <span className="label">Current Session:</span>
                <span className="value">{luciActivity.currentSession?.session_name || 'None'}</span>
              </div>
              <div className="status-item">
                <span className="label">Records Processed:</span>
                <span className="value">
                  {luciActivity.currentSession?.processed_records || 0} / 
                  {luciActivity.currentSession?.total_records || 0}
                </span>
              </div>
              <div className="status-item">
                <span className="label">Leads Queued:</span>
                <span className="value">{luciActivity.currentSession?.queued_leads || 0}</span>
              </div>
              <div className="progress-bar">
                <div 
                  className="progress-fill"
                  style={{ 
                    width: `${luciActivity.currentSession?.progress || 0}%` 
                  }}
                />
              </div>
            </div>
          )}
        </div>
        
        {/* Lead Pipeline */}
        <div className="dashboard-panel">
          <h3>ğŸ“Š Lead Pipeline</h3>
          <div className="pipeline-stages">
            {['new', 'contacted', 'engaged', 'qualified', 'proposal', 'closed'].map(status => (
              <PipelineStage 
                key={status}
                status={status}
                count={leadMetrics?.pipelineCounts?.[status] || 0}
                percentage={leadMetrics?.pipelinePercentages?.[status] || 0}
              />
            ))}
          </div>
        </div>
        
        {/* Active Leads */}
        <div className="dashboard-panel">
          <h3>ğŸ¯ Active Leads</h3>
          <div className="leads-list">
            {activeLeads.slice(0, 10).map(lead => (
              <LeadCard key={lead.id} lead={lead} />
            ))}
          </div>
        </div>
        
        {/* Campaign Performance */}
        <div className="dashboard-panel">
          <h3>ğŸ“± SMS Campaign Performance</h3>
          <div className="campaign-metrics">
            {campaignPerformance.map(campaign => (
              <CampaignMetricCard key={campaign.id} campaign={campaign} />
            ))}
          </div>
        </div>
      </div>
      
      {/* Lead Activity Timeline */}
      <div className="dashboard-panel full-width">
        <h3>ğŸ“ˆ Lead Activity Timeline</h3>
        <ActivityTimeline />
      </div>
    </div>
  );
}

// Component for individual lead cards
function LeadCard({ lead }: { lead: LeadRecord }) {
  const statusColors = {
    'new': '#gray',
    'contacted': '#blue',
    'engaged': '#yellow',
    'qualified': '#green',
    'proposal': '#purple',
    'closed': '#darkgreen'
  };
  
  return (
    <div className="lead-card">
      <div className="lead-header">
        <div className="lead-info">
          <h4>{lead.business_name}</h4>
          <span className="lead-id">{lead.lead_id}</span>
        </div>
        <span 
          className="status-badge"
          style={{ backgroundColor: statusColors[lead.current_status] }}
        >
          {lead.current_status}
        </span>
      </div>
      
      <div className="lead-details">
        <div className="detail-row">
          <span className="label">Owner:</span>
          <span className="value">{lead.owner_name || 'Unknown'}</span>
        </div>
        <div className="detail-row">
          <span className="label">Phone:</span>
          <span className="value">{lead.mobile_phone || lead.primary_phone}</span>
        </div>
        <div className="detail-row">
          <span className="label">Industry:</span>
          <span className="value">{lead.industry}</span>
        </div>
        <div className="detail-row">
          <span className="label">Priority:</span>
          <span className="value priority">{lead.priority_level}/100</span>
        </div>
      </div>
      
      <div className="lead-actions">
        <button className="action-btn">View Details</button>
        <button className="action-btn">Send SMS</button>
        <button className="action-btn">Update Status</button>
      </div>
    </div>
  );
}

// Pipeline stage component
function PipelineStage({ status, count, percentage }: { status: string; count: number; percentage: number }) {
  const statusLabels = {
    'new': 'New Leads',
    'contacted': 'Contacted',
    'engaged': 'Engaged',
    'qualified': 'Qualified',
    'proposal': 'Proposal',
    'closed': 'Closed'
  };
  
  return (
    <div className="pipeline-stage">
      <div className="stage-header">
        <span className="stage-name">{statusLabels[status]}</span>
        <span className="stage-count">{count}</span>
      </div>
      <div className="stage-bar">
        <div 
          className="stage-fill"
          style={{ width: `${percentage}%` }}
        />
      </div>
      <span className="stage-percentage">{percentage.toFixed(1)}%</span>
    </div>
  );
}

interface LeadMetrics {
  totalActiveLeads: number;
  leadsTrend: number;
  smsSentToday: number;
  smsTrend: number;
  responseRate: number;
  responseTrend: number;
  pipelineCounts: Record<string, number>;
  pipelinePercentages: Record<string, number>;
}

interface LuciActivity {
  activeSessions: number;
  sessionsTrend: number;
  currentSession?: {
    session_name: string;
    processed_records: number;
    total_records: number;
    queued_leads: number;
    progress: number;
  };
}
```

This comprehensive event-driven lead management system provides:

âœ… **Persistent ID Tracking**: Every lead gets immutable LeadID from first contact  
âœ… **LUCI AI Integration**: Event-driven activation on USBizData import  
âœ… **Skip Trace Automation**: Up to 2,000 records processed with owner discovery  
âœ… **Lead Queue Management**: Intelligent assignment with persistent AssignmentID  
âœ… **SMS Campaign Logging**: Every interaction tracked with ThreadID and EventID  
âœ… **Real-time Analytics**: Live dashboard showing lead lifecycle and performance  
âœ… **Complete Audit Trail**: All status changes, communications, and assignments logged  

The system ensures data integrity through relational mapping and provides comprehensive analytics across all lead interactions and campaign performance metrics.